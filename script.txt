use clap::{Parser, Subcommand};
use crystals_dilithium::dilithium5::{Keypair, PublicKey, Signature};
use std::fs;
use base64::{Engine as _, engine::general_purpose};
use chrono::Local;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};

const PGP_HEADER: &str = "-----BEGIN PGP PUBLIC KEY BLOCK-----";
const PGP_FOOTER: &str = "-----END PGP PUBLIC KEY BLOCK-----";
const PGP_SIG_HEADER: &str = "-----BEGIN PGP SIGNED MESSAGE-----";
const PGP_SIGNATURE_HEADER: &str = "-----BEGIN PGP SIGNATURE-----";
const PGP_SIGNATURE_FOOTER: &str = "-----END PGP SIGNATURE-----";

#[derive(Parser)]
#[command(name = "ML-DSA Tool")]
#[command(about = "ML-DSA87 (CRYSTALS-Dilithium 5) signature tool with OpenPGP-style output")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a new ML-DSA87 key pair
    Generate {
        /// Email address for the key
        #[arg(short, long, default_value = "user@example.com")]
        email: String,
        /// Output file for the key pair
        #[arg(short, long, default_value = "ml_dsa_key.json")]
        output: String,
    },
    /// Sign a file (clear sign within the file)
    Sign {
        /// Path to the file to sign
        #[arg(short, long)]
        file: String,
        /// Path to the key file
        #[arg(short, long, default_value = "ml_dsa_key.json")]
        key: String,
    },
    /// Verify a signed file
    Verify {
        /// Path to the signed file
        #[arg(short, long)]
        file: String,
        /// Path to the key file (for public key)
        #[arg(short, long, default_value = "ml_dsa_key.json")]
        key: String,
    },
    /// Get information about a key or signed file
    Info {
        /// Path to the file to inspect
        #[arg(short, long)]
        file: String,
    },
}

#[derive(Serialize, Deserialize)]
struct StoredKeyPair {
    keypair_bytes: Vec<u8>,
    public_key_bytes: Vec<u8>,
    email: String,
    created: String,
    fingerprint: String,
}

fn generate_fingerprint(key: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(key);
    let result = hasher.finalize();
    hex::encode(&result[..20]).to_uppercase()
}

fn format_pgp_public_key(email: &str, created: &str, fingerprint: &str, key_data: &[u8]) -> String {
    let encoded = general_purpose::STANDARD.encode(key_data);
    let wrapped = encoded.chars()
        .collect::<Vec<char>>()
        .chunks(64)
        .map(|c| c.iter().collect::<String>())
        .collect::<Vec<String>>()
        .join("\n");
    
    format!(
        "{}\n\
        Comment: User ID:\t{}\n\
        Comment: Valid from:\t{}\n\
        Comment: Type:\tML-DSA87 (CRYSTALS-Dilithium 5)\n\
        Comment: Usage:\tSigning, Certifying User IDs\n\
        Comment: Fingerprint:\t{}\n\
        \n\
        {}\n\
        {}",
        PGP_HEADER, email, created, fingerprint, wrapped, PGP_FOOTER
    )
}

fn clear_sign_file(content: &str, signature: &[u8]) -> String {
    let sig_encoded = general_purpose::STANDARD.encode(signature);
    let sig_wrapped = sig_encoded.chars()
        .collect::<Vec<char>>()
        .chunks(64)
        .map(|c| c.iter().collect::<String>())
        .collect::<Vec<String>>()
        .join("\n");
    
    format!(
        "{}\n\
        Hash: SHA256\n\
        \n\
        {}\n\
        {}\n\
        Version: ML-DSA Tool v0.1.0\n\
        Comment: Using ML-DSA87 (CRYSTALS-Dilithium 5)\n\
        \n\
        {}\n\
        {}",
        PGP_SIG_HEADER, content, PGP_SIGNATURE_HEADER, sig_wrapped, PGP_SIGNATURE_FOOTER
    )
}

fn extract_content_and_signature(signed_content: &str) -> Result<(String, Vec<u8>), String> {
    let parts: Vec<&str> = signed_content.split(PGP_SIGNATURE_HEADER).collect();
    if parts.len() != 2 {
        return Err("Invalid signed file format".to_string());
    }
    
    let content_part = parts[0]
        .trim_start_matches(PGP_SIG_HEADER)
        .trim_start_matches("Hash: SHA256")
        .trim();
    
    let sig_part = parts[1]
        .trim_end_matches(PGP_SIGNATURE_FOOTER)
        .lines()
        .filter(|line| !line.starts_with("Version:") && !line.starts_with("Comment:") && !line.is_empty())
        .collect::<Vec<&str>>()
        .join("");
    
    let signature = general_purpose::STANDARD
        .decode(sig_part)
        .map_err(|e| format!("Failed to decode signature: {}", e))?;
    
    Ok((content_part.to_string(), signature))
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Generate { email, output } => {
            println!("Generating ML-DSA87 key pair...");
            
            let keypair = Keypair::generate(None);
            
            let keypair_bytes = keypair.to_bytes();
            let public_key_bytes = keypair.public.to_bytes();
            let created = Local::now().format("%m/%d/%y %I:%M %p").to_string();
            let fingerprint = generate_fingerprint(&public_key_bytes);
            
            let key_data = StoredKeyPair {
                keypair_bytes: keypair_bytes.to_vec(),
                public_key_bytes: public_key_bytes.to_vec(),
                email: email.clone(),
                created: created.clone(),
                fingerprint: fingerprint.clone(),
            };
            
            // Save key pair
            let json = serde_json::to_string_pretty(&key_data)?;
            fs::write(&output, json)?;
            println!("Key pair saved to: {}", output);
            
            // Display public key in PGP format
            println!("\nPublic Key:\n");
            println!("{}", format_pgp_public_key(&email, &created, &fingerprint, &public_key_bytes));
            
            Ok(())
        }
        
        Commands::Sign { file, key } => {
            // Load key pair
            let key_json = fs::read_to_string(&key)?;
            let key_data: StoredKeyPair = serde_json::from_str(&key_json)?;
            
            // Load file content
            let content = fs::read_to_string(&file)?;
            
            // Recreate keypair from bytes
            let keypair = Keypair::from_bytes(&key_data.keypair_bytes);
            
            // Sign the content
            let signature = keypair.sign(&content.as_bytes());
            
            // Create clear-signed output
            let signed_content = clear_sign_file(&content, &signature);
            
            // Save to new file
            let output_path = format!("{}.asc", file);
            fs::write(&output_path, signed_content)?;
            
            println!("File signed successfully!");
            println!("Signed file saved to: {}", output_path);
            
            Ok(())
        }
        
        Commands::Verify { file, key } => {
            // Load key pair
            let key_json = fs::read_to_string(&key)?;
            let key_data: StoredKeyPair = serde_json::from_str(&key_json)?;
            
            // Load signed file
            let signed_content = fs::read_to_string(&file)?;
            
            // Extract content and signature
            let (content, signature_bytes) = extract_content_and_signature(&signed_content)?;
            
            // Create public key from bytes
            let public_key = PublicKey::from_bytes(&key_data.public_key_bytes);
            
            // Create signature object
            if signature_bytes.len() != 4595 {
                println!("✗ Invalid signature size. Expected 4595 bytes, got {}", signature_bytes.len());
                return Ok(());
            }
            let mut sig_array = [0u8; 4595];
            sig_array.copy_from_slice(&signature_bytes);
            let signature = Signature::from(sig_array);
            
            // Verify
            let is_valid = public_key.verify(&content.as_bytes(), &signature);
            
            if is_valid {
                println!("✓ Signature verification PASSED");
                println!("  Signed by: {}", key_data.email);
                println!("  Key fingerprint: {}", key_data.fingerprint);
            } else {
                println!("✗ Signature verification FAILED");
                println!("  The signature does not match the content or was made with a different key");
            }
            
            Ok(())
        }
        
        Commands::Info { file } => {
            if file.ends_with(".json") {
                // It's a key file
                let key_json = fs::read_to_string(&file)?;
                let key_data: StoredKeyPair = serde_json::from_str(&key_json)?;
                
                println!("Key Information:");
                println!("  Type: ML-DSA87 (CRYSTALS-Dilithium 5)");
                println!("  User ID: {}", key_data.email);
                println!("  Created: {}", key_data.created);
                println!("  Fingerprint: {}", key_data.fingerprint);
                println!("  Public key size: {} bytes", key_data.public_key_bytes.len());
                println!("  Full keypair size: {} bytes", key_data.keypair_bytes.len());
            } else if file.ends_with(".asc") {
                // It's a signed file
                let signed_content = fs::read_to_string(&file)?;
                let (content, signature) = extract_content_and_signature(&signed_content)?;
                
                println!("Signed File Information:");
                println!("  Signature algorithm: ML-DSA87 (CRYSTALS-Dilithium 5)");
                println!("  Hash algorithm: SHA256");
                println!("  Content size: {} bytes", content.len());
                println!("  Signature size: {} bytes", signature.len());
                println!("  First 50 chars of content: {}...", &content.chars().take(50).collect::<String>());
            } else {
                println!("Unknown file type. Expected .json (key file) or .asc (signed file)");
            }
            
            Ok(())
        }
    }
}